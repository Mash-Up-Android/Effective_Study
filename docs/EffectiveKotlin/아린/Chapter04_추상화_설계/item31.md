# 문서로 규약을 정의하라

```kotlin
fun Context.showMessage(
		message: String,
		duration: MessageLength = MessageLength.LONG
) {
		val toastDuration = when(duration) {
				SHORT -> Length.LENGTH_SHORT
				LONG -> Length.LENGTH_LONG
		}
		Toast.makeText(this, message, toastDuration).show()
}

enum class MessageLength {SHORT, LONG}
```

아이템 27에서 살펴본 코드이다.

`showMessage` 함수는 다른 개발자에게 단순히 토스트 출력 함수라고 생각될 수 있지만,
토스트가 아니라 다른 타입으로도 메시지 출력이 가능한 함수이다

따라서 함수의 기능을 명확하게 설명해주는 KDoc 주석을 달아주는 것이 좋다

`powerset` 이라는 멱집합 함수를 쓸 때도,
멱집합이 뭔지 모르는 개발자들을 위해 주석을 달고
요소 순서가 바뀌어도 영향이 없게끔 순서를 명확하게 지정하지 않아야 한다

<aside>
💡

함수의 **구현**에 의존하지 말고, 함수의 **행위**를 문서로 설명하도록 하자

</aside>

## 규약을 정의하는 이유

규약을 설정하지 않는다면, 클래스를 쓰는 사람은 스스로 할 수 있는 것과 없는 것을 모르게 되어
함수의 행위가 아닌, 구현의 세부적인 정보에 의존하게 된다

또한, 클래스를 만든 사람은 사용자가 무엇을 할 지 예측할 수 없어서 사용자의 구현을 망칠 위험이 있다

따라서, 규약을 정의하는 것은 양쪽에게 좋은 일이다

규약이 적절히 정의되어 있다면
클래스를 만든 사람은 클래스 사용 방법에 대해 걱정하지 않아도 되고, 이에 따라 원하는 부분을 마음대로 수정할 수있다

클래스를 쓰는 사람도 내부적인 구현을 신경쓰지 않고 믿을 수 있게 되어,
이에 의존하여 다른 무언가를 만들기 좋다

미리 정의된 규약을 서로 존중한다면 독립적으로 작업하게 되어도 정상적으로 작동할 수 있게 된다

## 규약 정의하기

### [1] 이름

일반적 개념의 메서드는 이름만으로 동작을 예측할 수 있다 (ex) sum

이 메서드가 무엇을 하는지 문서를 볼 필요 없이 이름만으로 알 수 있다

### [2] 주석과 문서

필요한 모든 규약을 적을 수 있다

### [3] 타입

함수의 리턴 타입과 아규먼트 타입은 객체의 많은 것을 알려준다.

자주 사용하지 않는 일부 타입은 문서에 따로 설명해주자.

> **주석을 써야할까?**
초기에는 문학적 프로그래밍으로 주석을 다는 것이 인기였지만,
로버트 마틴의 <클린 코드> 이후 주석 없이도 읽을 수 있는 프로그래밍 방식으로 바뀌었다

이름만으로 명확한 기능에 주석을 다는 것은 불필요하고,
추가적인 주석보다 함수 추출이 훨씬 가독성이 좋다

하지만 극단적인 것은 좋지 않다.
코틀린 표준 라이브러리의 public 함수가 규약을 잘 정리해두었기에, 자유도가 높아졌다
****현대의 주석은 문서 자동 생성에 많이 사용되기도 하고, 적당히 규약을 정의하는 것도 좋다
>

### KDoc 형식

주석으로 함수를 문서화하는 공식적인 형식이다

- `/**`로 시작해서 `*/`로 끝나고, 이 사이의 모든 줄은 `*`로 시작하여 작성한다
- KDoc 마크다운 형식으로 작성한다.
- 첫 번째 단락에 요약 설명을 작성한다
- 두 번째 단락에 상세 설명을 작성한다
- 그 이후에 각종 태그로 추가 정보를 작성한다
    - 이에 관련된 태그는 책을 통해 확인 가능하다

이러한 태그는, 공식적 코틀린 문서 생성 도구인 Dokka에서 사용 가능하다
Dokka 는 온라인, 외부 사용자에게 제공할 문서 파일을 만들어준다

## 타입 시스템과 예측

리스코스 치환 원칙에 따라, S가 T의 서브타입일 때 별도 변경 없이도 T 타입을 S 타입으로 대체할 수 있어야 한다
즉, 클래스가 어떤 동작을 할 것이라 예측되면 서브 클래스도 이를를 보장해야 한다

타입 계층은 객체의 중요한 정보다.

사용자가 클래스 동작을 확실하게 예측하려면, 공개 함수에 대한 규약을 잘 지정해야 한다

또한 구현의 세부 내용은 항상 조금씩 달라진다

그러므로 캡슐화를 통해 최대한 많이 보호하는 것이 좋다

캡슐화를 할 수록 사용자는 구현에 신경을 쓸 필요가 적어지므로 더욱 자유롭게 된다