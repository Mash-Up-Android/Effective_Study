# 요소의 가시성을 최소화하라

요소의 가시성을 최대한 제한하여 API를 간결하게 설계하는 것이 좋다

## 간결한 API를 설계해야 하는 이유

### 1. 인터페이스가 작을 수록 이를 공부하고 유지하기 쉽다

어떤 클래스를 수정하려면 그 클래스 전체를 이해하고 있어야하는데
보이는 요소가 적다면 유지보수 및 테스트가 적어진다

또, 기능이 많으면 이해하기 어려워지기 때문에 인터페이스는 작을 수록 배우기 쉽다

### 2. 최대한 제한되어 있어야 변경하기 쉽다

변경할 때에는 기존을 숨기는 것보다, 새로운 것을 노출하는 것이 쉽다

이미 공개적으로 노출되어 있는 요소들은 공개 API의 일부로, 외부에서 사용할 수 있기 때문에
이미 외부에서 사용되고 있을 것이다

즉, 이러한 요소들이 사용되는 모든 곳에서 영향을 받는다

가시성 관련 제한을 변경하는 것이 더 어렵고, 신중해야 한다

따라서 일부 요소 가시성을 제한하는 것 보다는, 처음부터 작은 API로 개발을 하는 것이 좋다

### 3. 클래스 상태를 나타내는 프로퍼티가 노출되어 있으면 클래스는 자신의 상태를 책임질 수 없다

클래스에는 클래스가 만족해야 할 상태에 대한 규악이 있을 수 있다

이러한 규약을 모르면, 클래스 상태를 마음대로 변경할 수 있게 되어서,
클래스 불변성이 무너질 수 있다

코틀린에서는 접근자의 가시성을 제한해서 모든 프로퍼티를 캡슐화하도록 하자

### 4. 가시성이 제한될 수록 API의 변경을 쉽게 추적 가능하다

서로 의존하는 프로퍼티가 있을 경우 객체 상태 보호가 더욱 중요해 진다

예상치 못한 변경에 의해 예외가 발생할 수 있기 때문이다

가시성이 제한될 수록 클래스 변경과 프로퍼티 상태를 더 쉽게 추적할 수 있다
→ 동시성 처리에 중요하다

많은 것을 제한할 수록 병렬 프로그래밍의 안전성을 높인다

## 가시성 한정자

내부적 변경이 없는 작은 인터페이스를 유지하기 위해, 가시성을 제한하여 외부 노출을 방지하자
가시성 제한은 다음의 가시성 한정자를 통해 구현할 수 있다

### 클래스 멤버

- public(기본값) : 어디에서나 볼 수 있음
- private : 클래스 내부에서만 볼 수 있음
- protect : 클래스, 서브 클래스 내부에서만 볼 수 있음
- internal : 모듈 내부에서만 볼 수 있음

### 톱레벨 요소

- public(기본값) : 어디에서나 볼 수 있음
- private : 같은 파일 내부에서만 볼 수 있음
- internal : 모듈 내부에서만 볼 수 있음

> - 모듈이 다른 모듈에 의해 서용될 수 있다면 internal로 공개하고 싶지 않은 요소는 숨긴다
- 상속을 위한 요소이고, 클래스와 서브 클래스에서만 쓰이게 한다면 protected를 쓴다
- 동일한 파일, 클래스에서만 요소를 쓰고 싶다면 private를 사용한다
>

<aside>
💡

**데이터 저장으로 설계된 클래스인 DTO(데이터 모델 클래스)에는 적용하지 말자.**

데이터를 저장하는 클래스는 숨길 이유가 없으므로
프로퍼티를 사용하도록 눈에 띄게 만드는 것이 좋다

필요 없다면 그냥 프로퍼티를 제거하자

</aside>

<aside>
💡

**API를 상속할 때 오버라이드로 가시성을 제한할 수 없다**

서브 클래스가 슈퍼 클래스로도 쓰일 수 있기 때문
→ 상속보다 컴포지션을 선호하는 대표적 이유

</aside>