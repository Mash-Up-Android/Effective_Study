# 일반적인 알고리즘을 반복해서 구현하지 말라

일반적이고 널리 사용되는 알고리즘(수학 연산, 범위 제한 등)은 괜히 직접 반복해서 구현하지 말고,

표준 라이브러리나 공통 유틸리티를 적극 활용하자

```kotlin
numbers.average()
```

average라는 함수를 이미 라이브러리에서 지원을 하고 있는데,

평균 계산 함수를 누가 굳이 만들어서 사용하는 것은 정말 불필요한 일이다

이미 있는 것을 활용하면

- 코드 작성 빠름
- 함수 이름만 가지고 함수 역할을 확실하게 알아낼 수 있음

괜히 다시 만들어서 사용하면 직접 구현하는 과정에서 실수가 발생할 수 있고, 최적화나 버그 수정의 혜택을 받지 못할 수도 있다

## 이미 있는 기능은 찾아서 쓰면 됨

코틀린 표준 라이브러리 함수들이 굉장히 풍부하니까 그거 쓰자

→ map, filter, groupBy, average 등등;;

특히 표준 라이브러리인 stdlib에는 굉장히 방대한 함수들이 많으니 알면 알수록 이득이다

## **직접 구현이 필요한 경우**

자주 쓰는 알고리즘이 없다면, 확장 함수나 유틸리티 함수로 만들어 재사용하면 됨

여러 번 사용하지 않는다고 해도, 구현해 둔다면 동료 개발자가 편하게 쓸 수 있을 것이다

단, 함수를 만들 때에는

1. 테스트 되어야 하고
2. 기억 되어야 하고
3. 유지보수 되어야 한다

이 점을 유의해서 필요없는 함수를 중복해서 만들지 않도록, 기존 함수를 적극 활용하자

**함수는 상태를 유지하지 않는다**

함수는 내부에 값을 저장해서 계속 기억하지 않는다.
즉, 함수가 호출될 때마다 항상 같은 입력값에 대해 같은 결과를 반환한다 ⇒  **행위를 나타내기 좋다**

**특히 부가 작용(사이드 이펙트)이 없을 때 더 좋다**

부가 작용이란 함수가 외부의 상태(전역 변수, 파일, 데이터베이스 등)를 변경하거나, 외부 상태에 따라 결과가 달라지는 것이다. 함수에 부가 작용이 없으면, 입력만으로 결과가 결정되기 때문에 예측하기 쉽고 테스트와 유지보수도 쉬워진다

### **톱레벨 함수 (Top-level function)**

톱레벨 함수는 **어떤 클래스 안에 포함되지 않은 함수로,** 파일이나 클래스 외부에 바로 정의된 함수

```kotlin
greet("아딘") // 어떤 객체가 없어도 그냥 호출 가능
```

간단하게 사용할 수 있지만 너무 일반적이라서 어디서든 호출될 수 있고, **특정 타입에 맞춰서 제한을 두기 어려운 단점 존재**

### 확장 함수

확장 함수는 특정 타입에 붙이는 함수

이 함수는 **구체적인 객체**에 대해만 호출할 수 있도록 제한할 수 있다는 장점이 있음

```kotlin
fun String.greet() {
    println("Hello, $this!")
}
```

## 아규먼트 VS 확장 리시버

```kotlin
data class Person(var name: String)

fun changeName(person: Person, newName: String) {
    person.name = newName
}
```

위 코드는 아규먼트로 **`person` 객체,** `newName`을 아규먼트로 받아서 그 객체의 이름을 변경한다

이 방식은 코드가 조금 더 길어지고, 수정하려는 객체가 외부에서 전달된다는 점에서 약간 부담스럽고 번거롭다고 느껴질 수 있다.

```kotlin
fun Person.changeName(newName: String) {
    this.name = newName
}

val person = Person("아딘")
person.changeName("아린")
println(person.name) 

```

**`changeName`** 함수는 `Person` 클래스의 확장 함수가 됨

이 함수는 **`Person` 객체에 대해** 직접 `name`을 변경할 수 있게 하고 **객체에 바로 속하는 함수**처럼 사용되기 때문에, 코드가 더 **간결하고 직관적**

또한,

```kotlin
TextUtils.isEmpty(”아린”) // A
"아린".isEmpty() // B
```

A보다 B코드를 사용하기 쉽다.

A처럼 isEmpty가 어디에 속해있는지 우리가 하나하나 알기 어렵고, B는 애초에 자동 완성 제안이 이뤄진다.