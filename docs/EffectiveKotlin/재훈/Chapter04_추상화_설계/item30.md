# 30. 요소의 가시성을 최소화하라

---

---

# 개요

간결한 API를 선호하는 이유

- 작은 인터페이스는 배우기 쉽고, 유지하기 쉬움
- 기능이 많은 클래스보다는 적은 클래스를 이해하는 것이 쉬움
- 유지보수하기 쉬움

일반적으로 어떤 수정을 가하기 위해서는 클래스 전체를 이해하고 있어야 함

보이는 요소 자체가 적다면, 유지보수하고 테스트할 것이 적음

변경을 할 때는 기존의 것을 숨기는 것보다 새로운 것을 노출하는 것이 쉬움

일반적으로 공개적으로 노출되어 있는 요소들은 공개 API의 일부이며, 외부에서 사용 가능

따라서 이러한 요소들은 이미 외부에서 사용되고 있을 것임

그래서 이런 요소들을 변경하면, 이 코드를 사용하는 모든 부분이 영향을 받음

가시성과 관련된 제한을 변경하는 것은 더 어려움

이러한 변경은 신중하게 고려해야 하며, 변경할 경우에는 대체재를 제공하는 것은 굉장히 어려움

→ 비즈니스 요구 사항이 무엇인지 빠르게 파악이 어렵기 때문

널리 사용되는 공개 라이브러리라면, 일부 요소의 가시성을 제한한 경우 여러 사용자가 분노할 수 있음

따라서 처음에는 작은 API로서 개발을 하도록 강제하는 것이 더 좋을 수 있음

클래스의 상태를 나타내는 프로퍼티를 외부에서 변경할 수 있다면, 클래스는 자신의 상태를 보장할 수 없음

클래스가 만족해야 하는 클래스의 상태에 대한 규약 등이 있을 수 있는데, 이러한 규약을 모르는 사람은 클래스의 상태를 마음대로 변경할 수 있으므로, 클래스 불변성(invariant)이 무너질 수 있음

일반적으로 코틀린에서는 구체 접근자의 가시성을 제한해서 모든 프로퍼티를 캡슐화하는 것이 좋음

서로서로 의존하는 프로퍼티가 있을 때는 객체 상태를 보호하는 것이 더 중요

가시성이 제한될수록 클래스의 변경을 쉽게 추적할 수 있으며, 프로퍼티의 상태를 더 쉽게 이해할 수 있음

→ 이는 동시성(concurrency)을 처리할 때 중요함

상태 변경은 병렬 프로그래밍에서 문제가 됨

따라서 많은 것을 제한할수록 병렬 프로그래밍을 할 때 안전해짐

---

# 가시성 한정자 사용하기

내부적인 변경 없이 작은 인터페이스를 유지하고 싶다면, 가시성(visibility)을 제한하면 됨

기본적으로 클래스와 요소를 외부에 노출할 필요가 없다면, 가시성을 제한해서 외부에서 접근할 수 없게 만드는 것이 좋음

가시성 제한은 가시성 한정자를 활용해서 구현 함

클래스 멤버의 가시성 한정자

- `public` : 어디에서나 볼 수 있음
- `private` : 클래스 내부에서만 볼 수 있음
- `protected` : 클래스와 서브 클래스 내부에서만 볼 수 있음
- `internal` : 모듈 내부에서만 볼 수 있음

톱레벨 요소의 가시성 한정자

- `public` : 어디에서나 볼 수 있음
- `private` : 같은 파일 내부에서만 볼 수 있음
- `internal` : 모듈 내부에서만 볼 수 있음

데이터를 저장하도록 설계된 클래스(DTO)에는 적용하지 않는 것이 좋음

→ 숨길 이유가 없기 때문

---

# 정리

- 요소의 가시성은 최대한 제한적인 것이 좋음
- 인터페이스가 작을수록 이를 공부하고 유지하는 것이 쉬움
- 최대한 제한이 되어 있어야 변경하기 쉬움
- 클래스의 상태를 나타내는 프로퍼티가 노출되어 있다면, 클래스가 자신의 상태를 책임질 수 없음
- 가시성이 제한되면 API의 변경을 쉽게 추적 가능

---