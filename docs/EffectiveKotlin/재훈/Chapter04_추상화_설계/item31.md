# 31. 문서로 규약을 정의하라

---

---

# 개요

함수가 무엇을 하는지 명확하게 설명하고 싶다면, KDoc 주석을 붙여주는 것이 좋음

일반적으로 대부분의 함수와 클래스는 이름만으로 예측할 수 없는 세부사항들을 갖고 있는데, 이를 위해 추가적인 설명이 필요함

일반적인 문제는 행위가 문서화되지 않고, 요소의 이름이 명확하지 않다면 이를 사용하는 사용자는 우리가 만들려고 했던 추상화 목표가 아닌, 현재 구현에만 의존하게 됨

이러한 문제는 예상되는 행위를 문서로 설명함으로써 해결함

---

# 규약

어떤 행위를 설명하면 사용자는 이를 일종의 약속으로 취급하며, 이를 기반으로 스스로 자유롭게 생각하던 예측을 조정함

이처럼 예측되는 행위를 요소의 규약(contract of element)이라고 부름

현실의 규약과 마찬가지로 규약의 당사자들은 서로 상대방이 규약을 안정적으로 계속 지킬 거라 믿음

규약이 적절하게 정의되어 있다면, 클래스를 만든 사람은 클래스가 어떻게 사용될지 걱정하지 않아도 됨

→ 따라서 규약만 지킨다면 원하는 부분을 마음대로 수정할 수 있음

클래스를 만드는 사람과 사용하는 사람 모두 미리 정의된 규약에 따라 독립적으로 작업 가능

→ 서로가 규약을 존중한다면, 독립적으로 작업해도 모든 것이 정상적으로 기능함

만약 규약을 설정하지 않는다면, 구현의 세부적인 정보에 의존하게 됨

---

# 규약 정의하기

규약을 정의하는 방법

- 이름 : 일반적인 개념과 관련된 메서드는 이름만으로 동작을 예측 가능
    
    ex. sum
    
- 주석과 문서 : 필요한 모든 규약을 적을 수 있는 강력한 방법
- 타입 : 객체에 대한 많은 것을 알려줌. 어떤 함수 선언에 있는, 리턴 타입과 아규먼트 타입은 큰 의미
    
    → 자주 사용되는 타입의 경우에는 타입만 보아도 어떻게 사용하는지 알 수 있지만, 일부 타입은 문서에 추가로 설명해야 함
    

---

# 주석을 써야 할까?

극단적인 것은 좋지 않음

코드만 읽어도 어느 정도 알 수 있는 코드를 만들어야 함

주석을 사용하면 더 많은 내용의 규약을 설명 가능

함수 이름과 파라미터만으로 정확하게 표현되는 요소에는 따로 주석을 넣지 않는 것이 좋음

주석을 다는 것보다 함수로서 추출하는 것이 훨씬 좋음

결론 : 주석은 굉장히 유용하고 중요 but 적당해야 함

---

# KDoc 형식

주석으로 함수를 문서화할 때 사용되는 공식적인 형식을 KDoc이라고 부름

모든 KDoc주석은 `/**` 로 시작해서 `**/` 로 끝나고, 이 사이 모든 줄은 `*`로 시작

KDoc 주석의 구조

- 첫 번째 부분은 요소에 대한 요약 설명
- 두 번째 부분은 상세 설명
- 이어지는 줄은 모두 태그로 시작(추가적인 설명을 위해 사용)

사용할 수 있는 태그

- `@param <name>` : '함수 파라미터' 또는 '클래스, 프로퍼티, 함수 타입 파라미터'를 문서화
- `@return` : 함수의 리턴값을 문서화
- `@constructor` : 클래스의 기본 생성자를 문서화
- `@receiver` : 확장 함수의 리시버를 문서화
- `@property <name>` : 명확한 이름을 갖고 있는 클래스의 프로퍼티를 문서화. 기본 생성자에 정의된 프로퍼티에 사용
- `@throws <class>`, `@exception <class>` : 메서드 내부에서 발생할 수 있는 예외를 문서화
- `@sample <identifier>` : 함수의 사용 예를 문서화
- `@see <identifier>` : 특정한 클래스 또는 메서드에 대한 링크를 추가
- `@author` : 요소의 작성자를 문서화
- `@since` : 요소에 대한 버전을 지정
- `@supress` : 문서에서 해당 요소를 제외. 외부에서 사용할 수는 있지만, 공식 API에 포함할 필요는 없는 요소에 지정

모든것을 설명할 필요는 없음

→ 짧으면서 명확하지 않은 부분을 자세하게 설명하는 문서가 좋은 문서임

---

# 타입 시스템과 예측

타입 계층(type hierarchy)은 객체와 관련된 중요한 정보임

인터페이스는 우리가 구현해야 한다고 약속한 메서드 목록 이상의 의미를 가짐

클래스와 인터페이스에도 여러 가지 예측이 들어감

클래스가 어떤 동작을 할 것이라 예측되면, 그 서브 클래스도 이를 보장해야 함

→ 이를 **라스코프 치환 원칙**이라고 부름

이 원칙은 객체 지향 프로그래밍에서 굉장히 중요

기본적으로 이는 '`S`가 `T`의 서브타입이라면, 별도의 변경이 없어도 `T` 타입 객체를 `S` 타입 객체로 대체할 수 있어야 한다'라고 이야기 함

그래서 클래스가 어떻게 동작할 거라는 예측 자체에 문제가 있으면, 이 클래스와 관련된 다양한 상속 문제가 발생 가능

사용자가 클래스의 동작을 확실하게 예측할 수 있게 하려면, 공개 함수에 대한 규약을 잘 지정해야 함

설명과 규약은 인터페이스를 유용하게 만듦

규약이 지켜지는 범위에서는 이를 구현하는 클래스를 자유롭게 만들어도 됨

---

# 조금씩 달라지는 세부 사항

구현의 세부적인 사항은 항상 조금씩 달라질 수 있지만, 최대한 많이 보호하는 것이 좋음

일반적으로 캡슐화를 통해서 이를 보호함

캡슐화는 '허용하는 범위'를 지정하는데 도움을 주는 도구임

캡슐화가 많이 적용될수록, 사용자가 구현에 신경을 많이 쓸 필요가 없어지므로, 더 많은 자유를 갖게 됨

---

# 정리

요소, 특히 외부 API(external API)를 구현할 때는 규약을 잘 정의해야 함

이러한 규약은 이름, 문서, 주석, 타입을 통해 구현할 수 있음

규약은 사용자가 객체를 사용하는 방법을 쉽게 이해하는 등 요소를 쉽게 예측할 수 있게 해줌

규약은 요소가 현재 어떻게 동작하고 앞으로 어떻게 동작할지를 사용자에게 전달해 줌

이를 기반으로 사용자는 요소를 확실하게 사용할 수 있고, 규약에 없는 부분을 변경할 수 있는 자유를 얻음

규약은 단순한 합의지만, 양쪽 모두가 그 합의를 존중한다면 큰 문제가 없을 것임

---