# item 16 프로퍼티는 동작이 아니라 상태를 나타내야 한다.

이번 아이템은 사실 심오하다.  
코틀린에서 프로퍼티의 의의 및 동작방식(자바와 비교)  
또한 코틀린내에서 getter/setter 커스텀을 쉽게 하도록 문법을 제공하지만 과연 객체의 계약으로 잡혀있는 getter/setter의 정의는 무엇인가?를 다룬다.  
하나하나 지식적인 측면과 철학적인 측면 모두 정리하고 넘어가자(사실 [item1](https://github.com/Mash-Up-Android/Effective_Study/blob/main/docs/EffectiveKotlin/%EC%B0%BD%ED%99%98/1%EC%9E%A5_%EC%95%88%EC%A0%95%EC%84%B1/item01.md)에서도 이 이야기를 이미했다.)

## 지식적인 측면 프로퍼티의 모든것
프로퍼티는 자바로 따지면 getter/setter/field로 되어있음은 이미 당연할 것이다.
그리고 커스텀 getter/setter 문법도 숨쉬듯이 사용할 것이다.  

프로퍼티가 함수기반으로 동작한다는것이 핵심이다.  

이미 당연한 이야기는 뒤에두고 "오호 다시보니 새롭네" 싶은 것들을 정리해보겠다.
- getter/setter 내부에서 field 를 사용할일이 없으면 backing field는 코틀린 내부적으로 생성하지 않음
- derived peroperty(파생 프로퍼티) 는 computed property, calculated property 라고도 부른다.(사실상 함수등으로 한번 래핑한 느낌)
- 코틀린에서 인터페이스에 프로퍼티를 선언할수 있는 이유는 프로퍼티가 사실상 함수기 떄문이다
    - 코틀린 인터페이스에서 그래서 초기값 설정 못함(필드가 생기니까)
    - 자바의 경우 인터페이스에서 상수 필드만 선언가능하다.(일반 필드는 불가하다)
- 필드를 open으로 열어서 상속하는것도 사실상 함수라 가능한것이다.(생각 좀만 해보면 당연하다)
- 프로퍼티 위임이 가능한것도 함수라 위임이 가능한거다(매커니즘이 연상되지 않는가?)
- 확장 프로퍼티도 만들 수 있다 -> 함수니까.
    - 근데 그냥 확장함수를 쓰지 이런게 있을 이유가 딱히 없는것 같다. 오히려 너무많은 방법을 제공해 좋지 못한 방향으로 이끄는것 같다.


## 개념적인(철학적인) 측면 getter/setter
