# item 26 함수의 추상화 레벨을 통일하라

제목은 굉장히 삐까뻔적한데 사실 함수분리하라는 이야기다.(물론 적절한 사이즈로 적절한 상황에 맞춰서 하는건 어렵지만)  

[ 추상화의 예시 ]
추상화 및 레이어드 아키텍처의 예시로 컴퓨터를 드는데 하드웨어 계층/어셈블리/프로그램언어/어플리케이션 이런식으로 계층의 예시를 보여준다.  
나는 이런 예시를 들떄 OSI7계층을 자주 인용하는데 뭐 둘다 좋은 예시로 들 수 있을것 같다.

[ 추상화의 대상 ]
나의 경우 추상화하면 타입이 바로 떠오르기 때문에(물론 문맥상 상황상 굉장히 많은 해석이 가능하지만) 클래스라는 시각에 갇힐수 있다.  
하지만 코드 덩어리라면 모두 추상화에 대상이 될수 있음을 환기시켜주는 아이템이였다.  
좁은 범위로 보면 함수도 추상화의 대상이고 조그마한 역할을 떼어내서 추상화 시키고 역할을 수행하게 하는 코드를 분할하는 행위의 기초가 되며  
큰 범위로 본다면 모듈, 프로그램 자체가 추상화의 대상이다.  

[ 좁은 추상화(함수 분리)의 효용 ]
함수를 행동이나 일정한 동작을 수행하는 세부적인 단위로 쪼개지 않고 하나의 함수에 로직이 모두 담겨있는 코드가 오래된 레거시에 많다고 한다.  
사실 이건 오래된 레거시 뿐만 아니라 분리에 대한 시도나 인식을 가지고 있지 않은 개발자라면 요즘에도 비슷한 품질의 코드가 나온다.  

이러한 코드를 리펙터링해서 추상화 계층을 중간에 밀어넣고 이미 더럽지만 들고갈수 밖에없는 코드(이미 상용에서 오래 검증되고 기획자체가 명확하지 않아 바꿀수 없는 코드) 구현체를  
그나마 읽을만하게 어떤 행위를 하는지 파악 할 수 있도록 정리하고 구현체를 단순 변경하여 기획의 변화에 기민하게 대응할 수 있도록 리펙터링하는게 우리의 의무이고 실력이지 않을까 싶다.  
요즘 이런 리펙터링을 진행하는데 막상 이런거 잘 깔끔하게 리펙터링하면 아주 찌리찌리 짜라짜라 쾌감이 몰려온다.(동네산책 뜯어고치는중 인데 짜릿짜릿하다)  
-> 결론적으로 점진적인 리펙터링 기법, 더러운 구현체 중간에 추상화된 타입계층 밀어넣기, 구현체를 최외각에 배치하여 코드를 안정적으로 만들기 등 재미있는 요소가 참 많다.  

결론적으로 이런것들을 판단하고 컨트롤 할수 있어야한다고 생각한다.
- 어떤 코드를 집어 들었을때 어떤것이 고수준이고 어떤것이 저수준이 되어야하는지
- 레이어를 명확히 분리하여 서로 의존관계를 끊어낼 수 있는지
- 의존방향을 의도하고 명확히 설정할 수 있는지
- 분리의 단위에 이유가 있는지(도메인에 적절한지)

[ 테스트 ]
책에서 단위테스트 이야기는 생략된거 너무 많다.  
근데 뭐 적어내기는 귀찮아서 이건 독자의 상상에 맡긴다.


